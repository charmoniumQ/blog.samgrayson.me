<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"/> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"> <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/icon/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/icon/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/icon/favicon-16x16.png"> <link rel="manifest" href="/assets/img/icon/site.webmanifest"> <link rel="mask-icon" href="/assets/img/icon/safari-pinned-tab.svg" color="#5bbad5"> <link rel="shortcut icon" href="/assets/img/icon/favicon.ico"> <meta name="msapplication-TileColor" content="#2b5797"> <meta name="msapplication-config" content="/assets/img/icon/browserconfig.xml"> <meta name="theme-color" content="#ffffff"> <title>Stop writing shell scripts</title> <meta name="author" content="Samuel Grayson"/> <link rel="stylesheet" href="https://samgrayson.me/assets/css/main2.css"/> <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.0/css/font-awesome.min.css"/> <link rel="stylesheet" href="/assets/css/bootstrap.min.css"/> <link rel="stylesheet" href="/assets/css/bootstrap-social.css"/> <link rel="stylesheet" href="/assets/css/main.css"/> <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"/> <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"/> <meta property="og:title" content="Stop writing shell scripts"/> <meta property="og:description" content="UNIX shell isn’t a real programming language, so stop using like one! There are occasions one has to use shell due to the structure of UNIX (e.g. the hash-bang, ~/.profile, /etc/init.d/). I won’t indict the REPL because one doesn’t have to maintain what one types in the REPL. As with..."> <meta property="og:type" content="website"/> <meta property="og:url" content="https://samgrayson.me/2021-01-01-shell/"/> <link rel="canonical" href="https://samgrayson.me/2021-01-01-shell/"/> <meta property="og:image" content="https://samgrayson.me/assets/img/logo/drawinghands.jpg"/> <meta name="twitter:card" content="summary"/> <meta name="twitter:site" content="@charmoniumQ"/> <meta name="twitter:creator" content="@charmoniumQ"/> <meta name="twitter:title" content="Stop writing shell scripts"/> <meta name="twitter:description" content="UNIX shell isn’t a real programming language, so stop using like one! There are occasions one has to use shell due to the structure of UNIX (e.g. the hash-bang, ~/.profile, /etc/init.d/). I won’t indict the REPL because one doesn’t have to maintain what one types in the REPL. As with..."> <meta name="twitter:image" content="https://samgrayson.me/assets/img/logo/drawinghands.jpg"/> <meta name="generator" content="Jekyll v3.8.6"/> <meta property="og:title" content="Stop writing shell scripts"/> <meta name="author" content="Samuel Grayson"/> <meta property="og:locale" content="en_US"/> <meta name="description" content="UNIX shell isn’t a real programming language, so stop using like one!"/> <meta property="og:description" content="UNIX shell isn’t a real programming language, so stop using like one!"/> <link rel="canonical" href="https://samgrayson.me/2021-01-01-shell/"/> <meta property="og:url" content="https://samgrayson.me/2021-01-01-shell/"/> <meta property="og:site_name" content="Interesting Thoughts"/> <meta property="og:image" content="https://samgrayson.me/assets/img/shell/moneyball.png"/> <meta property="og:type" content="article"/> <meta property="article:published_time" content="2021-01-01T00:00:00-06:00"/> <meta name="twitter:card" content="summary"/> <meta property="twitter:image" content="https://samgrayson.me/assets/img/shell/moneyball.png"/> <meta property="twitter:title" content="Stop writing shell scripts"/> <meta name="twitter:site" content="@charmoniumQ"/> <meta name="twitter:creator" content="@charmoniumQ"/> <script type="application/ld+json">
{"url":"https://samgrayson.me/2021-01-01-shell/","@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://samgrayson.me/assets/img/logo/drawinghands.jpg"},"name":"Samuel Grayson"},"headline":"Stop writing shell scripts","dateModified":"2021-01-01T00:00:00-06:00","datePublished":"2021-01-01T00:00:00-06:00","author":{"@type":"Person","name":"Samuel Grayson"},"image":"https://samgrayson.me/assets/img/shell/moneyball.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://samgrayson.me/2021-01-01-shell/"},"description":"UNIX shell isn’t a real programming language, so stop using like one!","@context":"https://schema.org"}</script> <link type="application/atom+xml" rel="alternate" href="https://samgrayson.me/feed.xml" title="Interesting Thoughts"/><link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css" integrity="sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ" crossorigin="anonymous"> </head> <body> <nav class="navbar navbar-default navbar-fixed-top navbar-custom"> <div class="container-fluid"> <div class="navbar-header"> <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="https://samgrayson.me">Interesting Thoughts</a> </div> <div class="collapse navbar-collapse" id="main-navbar"> <ul class="nav navbar-nav navbar-right"> <li> <a href="/about_me/">About Me</a> </li> </ul> </div> <div class="avatar-container"> <div class="avatar-img-border"> <a href="https://samgrayson.me "> <img class="avatar-img" src="/assets/img/logo/drawinghands.jpg"/> </a> </div> </div> </div> </nav> <div itemscope itemtype="http://schema.org/BlogPosting"> <header class="header-section "> <div class="intro-header no-img"> <div class="container"> <div class="row"> <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"> <div class="post-heading"> <h1 itemprop="headline"> <a href="/2021-01-01-shell/" itemprop="url"> Stop writing shell scripts </a> </h1> <span class="post-meta"> Occurred to me on <time itemprop="datePublished" datetime="2021-01-01">January 1, 2021</time> <br/><a href="#copyright"><img alt="See footer for license" style="border-width:0" src="/assets/img/footer/CC-BY.png"/></a> </span> <div class="blog-tags"> Tags: <a href="/tags#programming">programming</a> </div> </div> </div> </div> </div> </div> </header> <div class="container"> <div class="row"> <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"> <article role="main" class="blog-post"> <p>UNIX shell isn’t a real programming language, so stop using like one!</p> <p>There are occasions one <em>has</em> to use shell due to the structure of UNIX (e.g. the hash-bang, <code class="highlighter-rouge">~/.profile</code>, <code class="highlighter-rouge">/etc/init.d/</code>). I won’t indict the REPL because one doesn’t have to maintain what one types in the REPL. As with anything, there are cases where the entire system or team is historically based on UNIX shell and pushing against that inertia would cause immense pain, but every other automation task would be better in a language like Python, Ruby, or if you insist, even Perl.</p> <p>The distinguishing factor between these “real” programming languages and shell, for the purposes of this article, is the ability to define datatypes. There are strongly typed languages and weakly typed ones (both permit user-defined datatypes). Then there’s 50 feet of crap, and <em>then</em> there’s shell.</p> <p><img src="/assets/img/shell/moneyball.png"/></p> <p>A cornerstone of UNIX wisdom is that “plaintext is the universal interface.” Hence, it is not strongly typed; it’s <em>stringly</em> typed.</p> <ul> <li>After all, floats, ints, strings can all be encoded as strings.</li> <li>Lists of such can be colon-separated (like <code class="highlighter-rouge">$PATH</code>), space-separated (like shell arguments), tab-separated (like <code class="highlighter-rouge">ls -l $file</code>), or line-separated (like <code class="highlighter-rouge">find</code>).</li> <li>Lists of lists of such can be represented as a line-separated list of tab-separated lists (like <code class="highlighter-rouge">ls -l</code>). I call these <em>simple datatypes</em>. Representing <em>complex datatypes</em> is done on an even more ad hoc basis.</li> </ul> <h3 id="simple-datatypes">Simple datatypes</h3> <p>Even within simple datatypes, life is hard: if <code class="highlighter-rouge">var="name with space"</code>, then <code class="highlighter-rouge">command $var</code> expands to <code class="highlighter-rouge">command name with space</code> (<code class="highlighter-rouge">$var</code> is a makeshift list) rather than <code class="highlighter-rouge">command "name with space"</code> by default, when the programmer usually intends the latter. While this behavior can be avoided with quotes around <code class="highlighter-rouge">"$var"</code>, this default makes it easier to write shell scripts incorrectly in a way you won’t notice until you try a specially-crafted string.</p> <p>Quoting does not even solve the problem completely. Suppose <code class="highlighter-rouge">var='a "b c"'</code>. Then <code class="highlighter-rouge">"$var"</code> expands to one argument (<code class="highlighter-rouge">a "b c"</code>), while <code class="highlighter-rouge">$var</code> expands to three (<code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">"b</code>, and <code class="highlighter-rouge">c"</code>). According to the all-knowing <a href="https://superuser.com/questions/1066455/how-to-split-a-string-with-quotes-like-command-arguments-in-bash">Stack Overflow</a>, there is no variant which expands to two arguments (<code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b c</code>) short of writing your own lexer in shell or calling <code class="highlighter-rouge">eval</code>. Bash tries to fix this with arrays, (<code class="highlighter-rouge">var=(a "b c")</code> and <code class="highlighter-rouge">"${var[@]}"</code>), but critically there is no easy way to pass mulitple arrays as function arguments.</p> <p>A <a href="https://news.ycombinator.com/item?id=8442467">defender of shell</a> says “We should strive to build our software… so that exceptions like a filename with an odd character in it just don’t exist. Until we reach that point, computers will continue to frustrate their users for no good reason.” But there <strong>is</strong> a better way! It’s using a real programming language.</p> <p>The thorns of shell programming infect the rest of the system. For example, <code class="highlighter-rouge">$PATH</code> contains a colon-separated list-of-strings. What if one of those strings needs to have a colon in it? <code class="highlighter-rouge">scp</code> also uses a colon to separate two elements of a pair (the hostname and the path), but what if the filename contains a colon? Colon is technically <a href="https://en.wikipedia.org/wiki/Filename#Comparison_of_filename_limitations">a reserved character</a>, but this reservation is (usually) not checked when creating a file–apparently the system prefers to silently fail later on instead.</p> <p>Good luck using a string in shell to hold non-trivial encodings or binary data.</p> <h3 id="complex-datatypes">Complex datatypes</h3> <p>Complex datatypes are even more ad hoc. Perhaps, the designers of shell did not envision so many tools requiring complex datatypes. But today, a plethora tools I use regularly do. Instead of plaintext, many newer tools (<code class="highlighter-rouge">kubectl</code>, <code class="highlighter-rouge">gcloud</code>) often have an option to output structured data as JSON to losslessly emit data for a real programming language.</p> <p>The shell’s inability to natively represent datatypes affects how people think about the rest of the system. For example, how should the kernel communicate complex datastructures to userspace? Influenced by shell, which can’t define data structures, many Unices use the filesytem (<a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a> and <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a>) to communicate structured data. Unfortunately, over the years this has accumulated <a href="https://lwn.net/Articles/378884/">a plethora of different ad hoc representations</a> in Linux, and it is nearly impossible to <a href="https://lwn.net/Articles/356152/">take a consistent snapshot</a> of the data.</p> <p>I have a friend who says any system operation I can do in Python, he can do in an <code class="highlighter-rouge">awk</code>/<code class="highlighter-rouge">sed</code> one-liner. As a one-off command, I understand that’s a useful skill. But if you need to do this task in a stored procedure, this is the <em>least</em> maintainable option. If anyone needs to tweak the task (including the original author after one month), they usually have to figure out what it does and <em>rewrite another one</em>, hopefully in a real language this time.</p> <p>Even <a href="https://en.wikipedia.org/wiki/Eric_S._Raymond">Eric S. Raymond</a>, classic UNIX hacker, weighed in against shell:</p> <blockquote> <p>As a general scripting language shell sucks <em>really badly</em> compared to anything new-school. Performance, portability, you name it, it’s a mess. It’s not so much the shell interpreters itself that are the portabilty [sic] problem, but (as Magnus implicitly points out) all those userland dependencies on sed and tr and awk and even variants of expr(!) that get dragged in the second you try to get any actual work done.</p> <p>Some old-school Unix habits have persisted long past the point that they’re even remotely sane. Shell programming at any volume above a few lines of throwaway code is one of them - it’s <em>nuts</em> and we should <em>stop doing it</em>.</p> <p>Eric S. Raymond in <a href="https://lwn.net/Articles/527308/">LWN</a></p> </blockquote> <h3 id="knuth-vs-mcilroy-is-orthogonal-to-ditching-shell">Knuth vs McIlroy is orthogonal to ditching shell</h3> <p>Someone is bound to mention the famous spar between Doug McIlroy and Donald Knuth (much has been written regarding this: <a href="http://www.leancrew.com/all-this/2011/12/more-shell-less-egg/">summary</a>, <a href="https://buttondown.email/hillelwayne/archive/donald-knuth-was-framed/">Knuth was framed</a>, <a href="https://www.spinellis.gr/blog/20200225/">Knuth wasn’t framed</a>, <a href="https://news.ycombinator.com/item?id=18699718">HN debate</a>). Donald Knuth was asked to compute word frequencies from its input (“a” =&gt; 10, “the” =&gt; 7, “them” =&gt; 3, …). He wrote a 6-page Pascal program from scratch and invented a novel datastructure. Doug McIlroy wrote a 6-line shell program which did the same thing.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tr</span> <span class="nt">-cs</span> A-Za-z <span class="s1">'\n'</span> |
<span class="nb">tr </span>A-Z a-z |
<span class="nb">sort</span> |
<span class="nb">uniq</span> <span class="nt">-c</span> |
<span class="nb">sort</span> <span class="nt">-rn</span> |
<span class="nb">sed</span> <span class="k">${</span><span class="nv">1</span><span class="k">}</span>q
</code></pre></div></div> <p>The transferrable point of McIlroy’s comment was that Knuth built everything from scratch to maximize asymtotic performance, while McIlroy wrote an equivalent although less performant solution by cobbling together existing tools. Nothing about it is inherent to shell or pipes. I would offer this Python program:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span><span class="p">,</span> <span class="n">collections</span><span class="p">,</span> <span class="n">re</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">words</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">"[a-z]+"</span><span class="p">,</span> <span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
</code></pre></div></div> <p>I believe it carries the same lesson from McIlroy’s solution (since it reuses tools: <a href="https://docs.python.org/3/library/re.html">regular expressions</a> and <a href="https://docs.python.org/3/library/collections.html#collections.Counter">collections.Counter</a>), but unlike McIlroy’s solution, it’s easier to read, easier to modify (try making it split words containing apostrophes more intelligently), gives better error messages (try passing in a non-integer argument), and it’s about <a href="https://stackoverflow.com/a/56958255/1078199">4 times faster</a>.</p> <h3 id="poor-datatypes-implies-poor-programming-language-constructs">Poor datatypes implies poor programming-language constructs</h3> <p>Not everyone likes exceptions, but you have to agree a <em>stacktrace</em> is useful (for example, pass a non-integer argument to the previous program). Shell by default doesn’t even stop for errors, and if you unset that default (<code class="highlighter-rouge">set -e</code>), it doesn’t tell you what line errored out. You have to enable printing all lines (potentially many!) with <code class="highlighter-rouge">set -x</code> to get remotely useful diagnostics.</p> <p>It is difficult to do parallelism in shell. Because shell is based on fork-and-exec, there is no such thing as lightweight thread-level parallelism. As for process-level parallelism, you’ve got the option to manually pass around pids (<code class="highlighter-rouge">command &amp; ; pid="${!}"</code>), use <code class="highlighter-rouge">xargs</code>, or use <a href="https://www.gnu.org/software/parallel/">GNU Parallel</a>. It’s only fun for the very simplest kinds of problems.</p> <p>In many shell expressions, undefined variables behave the same as the empty-string (no datatype to represent <code class="highlighter-rouge">null</code>). This has led to horrible bugs that delete <a href="https://github.com/valvesoftware/steam-for-linux/issues/3671">the whole home directory</a>.</p> <p>Lack of datatypes implies the inability to statically <strong>or</strong> dynamically check types. Even Python can emit type-errors dynamically.</p> <p>Everything is a global by default.</p> <h1 id="actionable-advice">Actionable Advice</h1> <ol> <li> <p>Stop writing shell scripts! Instead reach for a <em>real</em> language like Python. You can still benefit from reusing software, but at a language-level.</p> </li> <li> <p>Write functions instead of scripts, function parameters instead of script arguments, <code class="highlighter-rouge">return</code> instead of <code class="highlighter-rouge">echo</code>, and objects instead of stringified data. This makes your software easier to reuse than a shell script.</p> </li> <li> <p>If you have to call out to shell, bubble-wrap the shell command in a regular function. This is good software engineering, it permits you to switch to a native API call later on, and <code class="highlighter-rouge">clang(..., debugging_symbols=True)</code> is far more readable than <code class="highlighter-rouge">clang ... -g</code> if you don’t remember what <code class="highlighter-rouge">-g</code> stands for.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">def</span> <span class="nf">clang</span><span class="p">(</span>
         <span class="n">sources</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Path</span><span class="p">],</span>
         <span class="n">executable</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s">"a.out"</span><span class="p">),</span>
         <span class="n">includes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
         <span class="n">libs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
         <span class="n">optimizations</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
         <span class="n">opt_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
         <span class="n">debugging_symbols</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
 <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
     <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span>
         <span class="s">"clang"</span><span class="p">,</span>
         <span class="o">*</span><span class="n">sources</span><span class="p">,</span>
         <span class="o">*</span><span class="p">[</span><span class="n">f</span><span class="s">"-I{include}"</span> <span class="k">for</span> <span class="n">include</span> <span class="ow">in</span> <span class="n">includes</span><span class="p">],</span>
         <span class="o">*</span><span class="p">[</span><span class="n">f</span><span class="s">"-l{lib}"</span> <span class="k">for</span> <span class="n">lib</span> <span class="ow">in</span> <span class="n">libs</span><span class="p">],</span>
         <span class="o">*</span><span class="p">[</span>
             <span class="s">"-f"</span> <span class="o">+</span> <span class="p">(</span><span class="s">""</span> <span class="k">if</span> <span class="n">enabled</span> <span class="k">else</span> <span class="s">"no-"</span><span class="p">)</span> <span class="o">+</span> <span class="n">optimization</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">'_'</span><span class="p">,</span> <span class="s">'-'</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">optimization</span><span class="p">,</span> <span class="n">enabled</span> <span class="ow">in</span> <span class="n">optimizations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
         <span class="p">],</span>
         <span class="n">f</span><span class="s">"-O{opt_level}"</span><span class="p">,</span>
         <span class="o">*</span><span class="p">([</span><span class="s">"-g"</span><span class="p">]</span> <span class="k">if</span> <span class="n">debugging_symbols</span> <span class="k">else</span> <span class="p">[]),</span>
         <span class="s">"-o"</span><span class="p">,</span> <span class="n">executable</span><span class="p">,</span>
     <span class="p">])</span>
</code></pre></div> </div> </li> <li> <p>If you <em>have</em> to talk to some other program by a command-line interface,</p> <ul> <li> <p>Implement a language-level interface first, and then a command-line interface that sanatizes the inputs and calls into the language-level interface. It’s good software engineering practice, and it also gives other programs the option of composing at the language-level. I like to use <a href="https://click.palletsprojects.com/en/7.x/"><code class="highlighter-rouge">click</code></a> for the CLI.</p> </li> <li> <p>Add a <code class="highlighter-rouge">--output={json,text,auto}</code>. <code class="highlighter-rouge">json</code> is good if the other program is written in a real programming language (they can just <code class="highlighter-rouge">json.load(sys.stdin)</code>). It also permits using <a href="https://stedolan.github.io/jq/"><code class="highlighter-rouge">jq</code></a> to slice-and-dice the JSON instead of <code class="highlighter-rouge">sed</code>/<code class="highlighter-rouge">awk</code> to slice-and-dice the text. <code class="highlighter-rouge">auto</code> can decided between them by checking if stdin is a TTY. Many UNIX tools already do something analogous to decide if they should colorize the output.</p> </li> <li> <p>stderr can be plaintext—that is probably going to be read by a human.</p> </li> <li> <p>Don’t use raw <code class="highlighter-rouge">print</code>s. You can use <a href="https://tqdm.github.io/docs/tqdm/">tqdm</a>, <a href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial">logging</a>, <a href="https://docs.python.org/3/library/warnings.html">warnings</a>, and exceptions instead. This makes it easier to gracefully reuse your code in another project.</p> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># Language-level interface
</span> <span class="k">def</span> <span class="nf">do_cool_thing</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
     <span class="o">...</span>
    
 <span class="k">def</span> <span class="nf">print_cool_thing</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
     <span class="o">...</span>

 <span class="c1"># Command-line interface
</span> <span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
     <span class="c1"># importing click here permits clients to use the
</span>     <span class="c1"># language-level interface without installing click
</span>     <span class="kn">import</span> <span class="nn">click</span>
    
     <span class="c1"># click parses a CLI options and generates `--help` text
</span>    
     <span class="o">@</span><span class="n">click</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
     <span class="o">@</span><span class="n">click</span><span class="o">.</span><span class="n">argument</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
     <span class="o">@</span><span class="n">click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
     <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
         <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s">"auto"</span><span class="p">:</span>
             <span class="nb">format</span> <span class="o">=</span> <span class="s">"text"</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span> <span class="k">else</span> <span class="s">"json"</span>

         <span class="n">result</span> <span class="o">=</span> <span class="n">do_cool_thing</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

         <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s">"json"</span><span class="p">:</span>
             <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
         <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s">"text"</span><span class="p">:</span>
             <span class="n">print_cool_thing</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
             <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s">"Unrecognized format {format!r}"</span><span class="p">)</span>
</code></pre></div> </div> </li> <li> <p>Packages are the only piece I don’t have a good strategy for yet. Here are the strategies I have tried:</p> <ul> <li> <p><code class="highlighter-rouge">try</code> importing a package, and if that fails <code class="highlighter-rouge">pip.main(["install", "--user", package])</code> (after confirming with the user of course). This option is best with only a few dependencies.</p> </li> <li> <p>Using <code class="highlighter-rouge">poetry</code>, <code class="highlighter-rouge">pipenv</code>, or raw <code class="highlighter-rouge">virtualenv</code> for each project. This requires writing a two-line shell script to call the script from with the virtualenv; shell may be structurally unavoidable there. This is best for projects with multiple related scripts.</p> </li> <li> <p>Using <code class="highlighter-rouge">cx_freeze</code> inside a <code class="highlighter-rouge">virtualenv</code> to compile your script into an executable which can be called from outside the <code class="highlighter-rouge">virtualenv</code>. This might also benefit from a shell “launcher” that checks to see if the binary is out-of-date with the source.</p> </li> <li> <p>Package the script with <a href="https://nixos.org/">Nix</a> (possibly using <a href="https://github.com/nix-community/poetry2nix">poetry2nix</a>). Your script runs in an OS-level virtual environment rather than language-level one. This is the most future-proof solution.</p> </li> </ul> </li> <li> <p>More advice regarding the CLI can be found at <a href="https://clig.dev/">clig.dev</a>.</p> </li> </ol> <p>I’ve implemented these ideas in many projects, including my most recent: <a href="https://illixr.github.io/">ILLIXR</a>. We used to have a shell script to build-and-run the system, then a <code class="highlighter-rouge">Makefile</code>, and then I upgraded it following the guidelines in this section to a <a href="https://github.com/ILLIXR/ILLIXR/tree/master/runner/runner/main.py">launcher script</a>. The script makes it far easier to launch ILLIXR different configurations programatically.</p> <h3 id="cons-of-a-real-language">Cons of a Real Language</h3> <ul> <li> <p>I must concede that the UNIX REPL, despite its warts, is efficient for those who invest time in it. It is useful to build a script out of commands one can test at a REPL.</p> <ul> <li>Perhaps real-language REPLs will become more ergonomic (like <a href="https://xon.sh/">Xonsh</a>), and satisfy the need for rapid prototyping while using real datatypes.</li> </ul> </li> <li> <p>Python is far more complex and difficult to implement from scratch than a shell.</p> </li> <li> <p>Python scripts are somewhat less portable since they depend on Python, but they are also somewhat more portable since Python is a compatibility layer over the underlying OS (most Python scripts are trivially Windows and UNIX compatibile!).</p> </li> <li> <p>It may be less debuggable, because the intermediates are not human-readable plaintext.</p> <ul> <li>This can be partly mitigated in two ways: In a language context, one can give objects a printable representation with<code class="highlighter-rouge">__str__/to_string</code> (often defined automatically); between processes, one can change<code class="highlighter-rouge">--format=json</code> to <code class="highlighter-rouge">--format=text</code>.</li> </ul> </li> <li> <p>Writing small shell utilities makes it easier to interact with other languages. Perhaps, <em>this</em> is Doug McIlroy’s vision. Not just reusing software but doing so at the CLI-level rather than language-level.</p> <ul> <li>This can be partly mitigated by writing a language-interface first and a shell-interface on top. This is common practice, as demonstrated by <a href="https://tqdm.github.io/">tqdm</a>, <a href="https://pyserial.readthedocs.io/en/latest/tools.html#module-serial.tools.miniterm">Pyserial’s miniterm</a>, <a href="https://pypi.org/project/jinja-cli/">jinja-cli</a>, and <a href="https://docs.python.org/3/library/http.server.html"><code class="highlighter-rouge">http.server</code></a>.</li> </ul> </li> </ul> <h3 id="a-new-vision-for-shell">A new vision for shell?</h3> <p>The case against using the UNIX shell as a REPL is less clear cut. Most of my arguments regarding maintainability and edge-cases carry less weight at the REPL since they only have to work once, under an engineer’s supervision. Any change to the shell threatens the existing repertoire of “muscle memory,” honed over decades. But even only as a hypothetical consideration, it is worth imagining what shell <em>could</em> be if it supported datatypes natively.</p> <p>Inventing a language is hard work, so why not reuse an existing one? Most existing languages are a bit too verbose, butone can write a front-end with syntactic sugar. This is exactly what <a href="https://xon.sh/">Xonsh</a> and <a href="http://ammonite.io/#Ammonite-Shell">Ammonite</a> do. Although the resulting syntax may resemble UNIX shell, real datatypes are flowing through the pipes. See <a href="https://docs.google.com/presentation/d/11vZzXCfAA0aOFAuHA0nAvAzALGFGCH-dqHxx6XMgbk8/edit#slide=id.g646dd4f7f_0_162">Beyond Bash</a> for an exposition of this philosophy by Ammonite’s creator.</p> <p>A more revolutionary approach is to fulfill the vision of shell, but in a modern context with datatypes. This is what PowerShell tries to be.</p> <blockquote> <p>I originally took the UNIX tools and made them available on Windows, and then it just didn’t work. Right? Because there’s a core architectural difference between Windows and Linux. On Linux, everything’s an ASCII text file… In Windows, everything’s an API that returns structured data… I came up with this idea of PowerShell… It’s a pipeline of objects and with the objects, you know, there’s none of the prayer-based parsing.</p> <p>–Jeffrey Snover in an interview with <a href="https://www.heavybit.com/library/podcasts/to-be-continuous/ep-37-the-man-behind-windows-powershell/">To Be Continuous</a></p> </blockquote> <h1 id="discussions">Discussions</h1> <p>This is not an original idea, but I think my presentation of it is unique.</p> <ul> <li><a href="https://news.ycombinator.com/item?id=3329668">This HN thread</a> is particularly prescient. <ul> <li><code class="highlighter-rouge">jhpriestley</code> reads McIlroy’s point about composition specifically to shell, while I would say that reusing language libraries is “composition” as well.</li> <li><code class="highlighter-rouge">nwmcsween</code> says exactly what I was thinking, “Composition should be of libraries or algorithms not arbitrary black box programs with n different options”. But I would amend this to say that black-box composition is a <em>fallback</em> if you have to go between languages and don’t have enough time to write a native API.</li> </ul> </li> <li> <p>Ted Kaminski applies a similar critique <a href="https://www.tedinski.com/2018/05/08/case-study-unix-philosophy.html">to UNIX philosophy</a> more broadly; he says what I am trying to far more generally and eloquently. I have chosen to focus my ire on just shell scripts because I hope to make more progress arguing the most narrow, concrete, and practical point first.</p> </li> <li><a href="https://news.ycombinator.com/item?id=8437687">This HN Thread</a> also features a lively debate. <ul> <li><code class="highlighter-rouge">felixgallo</code> points out that teaching shell is easier than teaching a map, reduce, and filter. I won’t argue the subjective point of which is easier, but it is incontroversial that most CS students are more interested in learning a real language than shell for employability reasons.</li> <li><code class="highlighter-rouge">rsync</code> says there is no better alternative, while <code class="highlighter-rouge">felixgallo</code> claims one is 20 years away, since existing tools would have to be ported. Here’s the better alternative: Python for scripts, Xonsh for REPL. It already has an equivalent of most tools (<code class="highlighter-rouge">ls -&gt; os.listdir</code>, <code class="highlighter-rouge">tr -&gt; re.sub</code>, etc.), the tools can be trivially ported (like <code class="highlighter-rouge">wc -l -&gt; open(...).read().count("\n")</code>), or existing tools can just be wrapped in a function that calls out to shell.</li> </ul> </li> </ul> <p>I am genuinely interested in opposing opinions, so drop a comment explaining why shell scripts are useful. Disqus’s free tier now has disgusting ads, so I switched away from it. You can comment in one of these places instead:</p> <ul> <li><a href="https://news.ycombinator.com/item?id=25604501">HackerNews</a></li> <li><a href="https://twitter.com/charmoniumQ/status/1345049520602828801">Twitter</a></li> </ul> <p><img src="/assets/img/shell/winter-is-coming.jpg"/></p> </article> <div class="blog-tags"> Tags: programming </div> <section id="social-share-section"> <a href="https://twitter.com/intent/tweet?text=Stop+writing+shell+scripts+https://samgrayson.me/2021-01-01-shell/" class="btn btn-social-icon btn-twitter" title="Share on Twitter"> <span class="fa fa-fw fa-twitter" aria-hidden="true"></span> </a> <a href="https://www.facebook.com/sharer/sharer.php?u=https://samgrayson.me/2021-01-01-shell/" class="btn btn-social-icon btn-facebook" title="Share on Facebook"> <span class="fa fa-fw fa-facebook" aria-hidden="true"></span> </a> <a href="https://plus.google.com/share?url=https://samgrayson.me/2021-01-01-shell/" class="btn btn-social-icon btn-google" title="Share on Google+"> <span class="fa fa-fw fa-google-plus" aria-hidden="true"></span> </a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://samgrayson.me/2021-01-01-shell/" class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn"> <span class="fa fa-fw fa-linkedin" aria-hidden="true"></span> </a> </section> <ul class="pager blog-pager"> <li class="previous"> <a href="/2020-12-27-fourteenth/" data-toggle="tooltip" data-placement="top" title="The Most Important Constitutional Amendment You've Never Heard Of">&larr; Previous Post</a> </li> </ul> <div class="disqus-comments"> </div> </div> </div> </div> <footer> <div class="container beautiful-jekyll-footer"> <div class="row"> <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"> <ul class="list-inline text-center footer-links"> <li> <a href="https://github.com/charmoniumQ" title="GitHub"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i> </span> </a> </li> <li> <a href="https://twitter.com/charmoniumQ" title="Twitter"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i> </span> </a> </li> <li> <a href="https://reddit.com/u/charmoniumQ" title="Reddit"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-reddit fa-stack-1x fa-inverse"></i> </span> </a> </li> <li> <a href="https://linkedin.com/in/SamGrayson" title="LinkedIn"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i> </span> </a> </li> <li> <a href="https://stackoverflow.com/users/1078199/charmoniumq" title="StackOverflow"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-stack-overflow fa-stack-1x fa-inverse"></i> </span> </a> </li> </ul> <p class="copyright text-muted" id="copyright"> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a> <br/>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>. <br/>Click an image for its attribution. No link means it is originally mine and licensed with the text. <br/>Source code is available <a href="https://github.com/charmoniumQ/blog-content">on GitHub</a>. <br/>Theme by <a href="http://deanattali.com/beautiful-jekyll/">beautiful-jekyll</a>. <br/>Share with love <i class="fa fa-heart" aria-hidden="true"></i> </p> </div> </div> </div> </footer> <script>
      	if (typeof jQuery == 'undefined') {
          var script = document.createElement('script');
          script.src = "/assets/js/jquery-1.11.2.min.js";
          document.write(script.outerHTML);
      	}
      </script> <script src="/assets/js/bootstrap.min.js"></script> <script src="/assets/js/main.js"></script> <script src="/assets/js/anchor_links.js"></script> <script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		ga('create', 'UA-145087833-1', 'auto');
		ga('send', 'pageview');
	</script> </body> </html>